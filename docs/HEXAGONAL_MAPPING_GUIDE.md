# üéØ Hexagonal Architecture: Mapping & Separation Guide

## üìå Golden Rule

```
MAPPING itu technical concern ‚Üí belongs to ADAPTER!

External Format (DTO/Entity) ‚Üí ADAPTER ‚Üí Domain
Domain ‚Üí ADAPTER ‚Üí External Format (Response/DTO)

Service HANYA tahu Domain!
```

---

## ‚ùì Kapan Logic Dianggap "Terlalu Banyak"?

### ‚úÖ **BAGUS** kalau:

1. **Setiap layer punya 1 tanggung jawab jelas**
   - Domain = business rules
   - Service = orchestration + validation
   - Adapter = technical details (API call, DB query, formatting)

2. **Easy to test**
   ```java
   @Test
   void shouldApplyCustomerFee() {
       BillItem item = new BillItem(...);
       BillItem result = item.applyCustomerFee("1000");
       // ‚úÖ Simple, focused test
   }
   ```

3. **Easy to change**
   - Ganti format amount? Ubah di adapter aja
   - Ganti business rule fee? Ubah di domain aja
   - Ganti API endpoint? Ubah di adapter aja

### ‚ùå **TIDAK BAGUS** kalau:

1. **Semua logic jadi 1 dalam service/helper method**
2. **Mixing technical details + business logic**
3. **Hard to test tanpa mock banyak dependencies**
4. **Method lebih dari 20 baris dengan nested logic**

### üìè Rule of Thumb

```
Kalau kamu nanya:
"Method ini sudah terlalu panjang ga ya?"

Jawaban:
‚úÖ Pecah kalau method > 20 baris
‚úÖ Pecah kalau ada nested if/for
‚úÖ Pecah kalau mixing concerns
‚úÖ Extract ke domain method untuk business logic
‚úÖ Extract ke helper untuk technical details
```

---

## üèóÔ∏è 3 Layer Architecture

### **1Ô∏è‚É£ Domain Layer** (Pure Business)

**Location:** `domain/entity/`

**Responsibility:**
- Business entities (records/classes)
- Business rules & validation
- Pure Java - NO annotations, NO dependencies

**Example:**
```java
// domain/entity/PulsaBalance.java
public record PulsaBalance(
    String phoneNumber,
    BigDecimal balance,
    String operator,
    String status
) {
    /**
     * ‚úÖ Business rule: Valid phone format
     */
    public static boolean isValidPhone(String phone) {
        return phone != null && phone.matches("^\\d{12}$");
    }
    
    /**
     * ‚úÖ Business rule: Active balance
     */
    public boolean isActive() {
        return balance != null && balance.compareTo(BigDecimal.ZERO) > 0;
    }
    
    /**
     * ‚úÖ Business rule: Apply fee
     */
    public PulsaBalance withFee(BigDecimal fee) {
        return new PulsaBalance(
            this.phoneNumber,
            this.balance.subtract(fee),
            this.operator,
            this.status
        );
    }
}
```

---

### **2Ô∏è‚É£ Application Layer** (Orchestration)

**Location:** 
- `application/port/in/` - Input Ports (Use Cases)
- `application/port/out/` - Output Ports (Dependencies)
- `application/service/` - Service implementations

**Responsibility:**
- Define contracts (ports/interfaces)
- Orchestrate business flow
- Call output ports
- Apply business logic
- **NO technical details!**
- **NO DTO mapping!**

**Example - Input Port:**
```java
// application/port/in/CheckBalanceUseCase.java
public interface CheckBalanceUseCase {
    Mono<PulsaBalance> checkBalance(String phoneNumber);
}
```

**Example - Output Ports:**
```java
// application/port/out/LoadBalancePort.java
public interface LoadBalancePort {
    Mono<PulsaBalance> loadBalance(String phoneNumber);
}

// application/port/out/CacheBalancePort.java
public interface CacheBalancePort {
    Mono<PulsaBalance> get(String phoneNumber);
    Mono<Void> put(String phoneNumber, PulsaBalance balance);
}
```

**Example - Service:**
```java
// application/service/PulsaBalanceService.java
@Service
public class PulsaBalanceService implements CheckBalanceUseCase {
    
    private final LoadBalancePort loadBalancePort;
    private final CacheBalancePort cacheBalancePort;
    
    public PulsaBalanceService(
        LoadBalancePort loadBalancePort,
        CacheBalancePort cacheBalancePort
    ) {
        this.loadBalancePort = loadBalancePort;
        this.cacheBalancePort = cacheBalancePort;
    }
    
    @Override
    public Mono<PulsaBalance> checkBalance(String phoneNumber) {
        
        // ‚úÖ Business logic: validation
        if (!PulsaBalance.isValidPhone(phoneNumber)) {
            return Mono.error(new IllegalArgumentException("Invalid phone"));
        }
        
        // ‚úÖ Orchestration: cache-aside pattern
        return cacheBalancePort.get(phoneNumber)
            .switchIfEmpty(
                loadBalancePort.loadBalance(phoneNumber)
                    .flatMap(balance -> 
                        cacheBalancePort.put(phoneNumber, balance)
                            .thenReturn(balance)
                    )
            )
            // ‚úÖ Business logic: filter inactive
            .filter(PulsaBalance::isActive)
            .switchIfEmpty(
                Mono.error(new RuntimeException("Balance inactive"))
            );
    }
}
```

**What Service Knows:**
- ‚úÖ Domain entities (`PulsaBalance`)
- ‚úÖ Ports (interfaces)
- ‚úÖ Business rules

**What Service DOESN'T Know:**
- ‚ùå DTO classes
- ‚ùå Database entities
- ‚ùå Redis
- ‚ùå WebClient
- ‚ùå API URLs
- ‚ùå JSON format

---

### **3Ô∏è‚É£ Infrastructure Layer** (Technical Details + MAPPING)

**Location:**
- `infrastructure/client/` - External API clients (Secondary Adapters)
- `infrastructure/persistence/` - Database repositories (Secondary Adapters)
- `infrastructure/cache/` - Cache implementations (Secondary Adapters)
- `infrastructure/web/` - REST controllers (Primary Adapters)
- `infrastructure/composite/` - Composite adapters (Routing logic)

**Responsibility:**
- Implement output ports
- Call external systems (API, DB, Cache)
- **‚úÖ MAPPING DTO ‚Üî Domain**
- **‚úÖ Technical details (formatting, parsing, etc)**
- Return domain objects to service

---

#### **A. Secondary Adapter - API Client**

```java
// infrastructure/client/OperatorApiClient.java
@Component
public class OperatorApiClient implements LoadBalancePort {
    
    private final WebClient webClient;
    
    public OperatorApiClient(WebClient webClient) {
        this.webClient = webClient;
    }
    
    @Override
    public Mono<PulsaBalance> loadBalance(String phoneNumber) {
        return webClient.get()
            .uri("/balance?phone={phone}", phoneNumber)
            .retrieve()
            .bodyToMono(BalanceDto.class)  // ‚Üê External DTO
            .map(this::toDomain);           // ‚úÖ MAPPING HERE!
    }
    
    /**
     * ‚úÖ MAPPING: External DTO ‚Üí Domain
     * Technical responsibility
     */
    private PulsaBalance toDomain(BalanceDto dto) {
        return new PulsaBalance(
            dto.getPhone(),
            parseBalance(dto.getBalance()),  // ‚úÖ Parsing here
            dto.getOperator(),
            dto.getStatus()
        );
    }
    
    /**
     * ‚úÖ Technical utility: parse string to BigDecimal
     */
    private BigDecimal parseBalance(String balance) {
        return new BigDecimal(balance);
    }
}

/**
 * DTO - External API format (infrastructure concern)
 */
@Data
class BalanceDto {
    private String phone;
    private String balance;  // String from API
    private String operator;
    private String status;
}
```

---

#### **B. Secondary Adapter - Cache**

```java
// infrastructure/cache/RedisBalanceCache.java
@Component
public class RedisBalanceCache implements CacheBalancePort {
    
    private final RedisTemplate<String, PulsaBalance> redisTemplate;
    
    public RedisBalanceCache(RedisTemplate<String, PulsaBalance> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    
    @Override
    public Mono<PulsaBalance> get(String phoneNumber) {
        return Mono.fromCallable(() -> {
            String key = buildKey(phoneNumber);  // ‚úÖ Technical detail
            return redisTemplate.opsForValue().get(key);
        });
    }
    
    @Override
    public Mono<Void> put(String phoneNumber, PulsaBalance balance) {
        return Mono.fromRunnable(() -> {
            String key = buildKey(phoneNumber);  // ‚úÖ Technical detail
            redisTemplate.opsForValue().set(
                key, 
                balance, 
                Duration.ofMinutes(5)  // ‚úÖ TTL logic
            );
        });
    }
    
    /**
     * ‚úÖ Technical utility: build cache key
     */
    private String buildKey(String phoneNumber) {
        return "balance:" + phoneNumber;
    }
}
```

---

#### **C. Primary Adapter - Controller**

```java
// infrastructure/web/PulsaController.java
@RestController
@RequestMapping("/api/pulsa")
public class PulsaController {
    
    private final CheckBalanceUseCase checkBalanceUseCase;
    
    public PulsaController(CheckBalanceUseCase checkBalanceUseCase) {
        this.checkBalanceUseCase = checkBalanceUseCase;
    }
    
    @GetMapping("/balance/{phone}")
    public Mono<BalanceResponse> checkBalance(@PathVariable String phone) {
        return checkBalanceUseCase.checkBalance(phone)
            .map(BalanceResponse::from);  // ‚úÖ Domain ‚Üí Response DTO
    }
}

/**
 * Response DTO - HTTP response format
 */
record BalanceResponse(
    String phoneNumber,
    String balance,
    String operator,
    String status
) {
    /**
     * ‚úÖ MAPPING: Domain ‚Üí Response DTO
     */
    static BalanceResponse from(PulsaBalance balance) {
        return new BalanceResponse(
            balance.phoneNumber(),
            balance.balance().toString(),  // ‚úÖ BigDecimal ‚Üí String
            balance.operator(),
            balance.status()
        );
    }
}
```

---

#### **D. Composite Adapter - Multiple Providers**

Ketika ada multiple providers (Telkomsel, XL, Indosat), gunakan **Composite Pattern**:

```java
// infrastructure/composite/OperatorComposite.java
@Component
@Primary  // ‚Üê This will be injected by default
public class OperatorComposite implements LoadBalancePort {
    
    private final TelkomselApiClient telkomselClient;
    private final XLApiClient xlClient;
    private final IndosatApiClient indosatClient;
    
    public OperatorComposite(
        TelkomselApiClient telkomselClient,
        XLApiClient xlClient,
        IndosatApiClient indosatClient
    ) {
        this.telkomselClient = telkomselClient;
        this.xlClient = xlClient;
        this.indosatClient = indosatClient;
    }
    
    @Override
    public Mono<PulsaBalance> loadBalance(String phoneNumber) {
        String operator = detectOperator(phoneNumber);
        
        // ‚úÖ Routing logic in adapter, not service!
        return switch(operator) {
            case "TELKOMSEL" -> telkomselClient.loadBalance(phoneNumber);
            case "XL" -> xlClient.loadBalance(phoneNumber);
            case "INDOSAT" -> indosatClient.loadBalance(phoneNumber);
            default -> Mono.error(
                new RuntimeException("Unknown operator: " + operator)
            );
        };
    }
    
    /**
     * ‚úÖ Technical utility: detect operator from phone prefix
     */
    private String detectOperator(String phoneNumber) {
        if (phoneNumber.startsWith("6281")) return "TELKOMSEL";
        if (phoneNumber.startsWith("6287")) return "XL";
        if (phoneNumber.startsWith("6285")) return "INDOSAT";
        throw new IllegalArgumentException("Unknown prefix");
    }
}

// Each provider adapter
@Component
class TelkomselApiClient implements LoadBalancePort {
    // Telkomsel-specific API call + mapping
}

@Component
class XLApiClient implements LoadBalancePort {
    // XL-specific API call + mapping
}

@Component
class IndosatApiClient implements LoadBalancePort {
    // Indosat-specific API call + mapping
}
```

**Service tidak berubah!**
```java
// Service tetap simple
return loadBalancePort.loadBalance(phone);  // Routing handled by composite
```

---

## üîÑ Complete Flow Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  REQUEST: GET /api/pulsa/balance/628123456789           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PRIMARY ADAPTER: PulsaController                        ‚îÇ
‚îÇ  - Receives HTTP request                                 ‚îÇ
‚îÇ  - Extract: phone = "628123456789"                       ‚îÇ
‚îÇ  - Call: checkBalanceUseCase.checkBalance(phone)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  APPLICATION: PulsaBalanceService                        ‚îÇ
‚îÇ  ‚úÖ Validate: isValidPhone(phone)                        ‚îÇ
‚îÇ  ‚úÖ Try cache: cacheBalancePort.get(phone)               ‚îÇ
‚îÇ  ‚úÖ If miss ‚Üí loadBalancePort.loadBalance(phone)         ‚îÇ
‚îÇ  ‚úÖ Filter: balance.isActive()                           ‚îÇ
‚îÇ  ‚úÖ Return: Mono<PulsaBalance> (domain)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚Üì                       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ RedisBalanceCache   ‚îÇ  ‚îÇ OperatorApiClient   ‚îÇ
‚îÇ (Secondary Adapter) ‚îÇ  ‚îÇ (Secondary Adapter) ‚îÇ
‚îÇ                     ‚îÇ  ‚îÇ                     ‚îÇ
‚îÇ Technical:          ‚îÇ  ‚îÇ Technical:          ‚îÇ
‚îÇ - Redis ops         ‚îÇ  ‚îÇ - WebClient call    ‚îÇ
‚îÇ - Key format        ‚îÇ  ‚îÇ ‚úÖ MAPPING:         ‚îÇ
‚îÇ - TTL logic         ‚îÇ  ‚îÇ    BalanceDto       ‚îÇ
‚îÇ                     ‚îÇ  ‚îÇ    ‚Üí PulsaBalance   ‚îÇ
‚îÇ Return: Domain      ‚îÇ  ‚îÇ Return: Domain      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì                       ‚Üì
    [Redis Cache]          [External API]
                     ‚Üì
         (back to Service, then Controller)
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PRIMARY ADAPTER: PulsaController                        ‚îÇ
‚îÇ  - Receives: Mono<PulsaBalance> (domain)                 ‚îÇ
‚îÇ  ‚úÖ MAPPING: PulsaBalance ‚Üí BalanceResponse              ‚îÇ
‚îÇ  - Return: JSON                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  RESPONSE: JSON to client                                ‚îÇ
‚îÇ  {                                                       ‚îÇ
‚îÇ    "phoneNumber": "628123456789",                        ‚îÇ
‚îÇ    "balance": "50000",                                   ‚îÇ
‚îÇ    "operator": "TELKOMSEL",                              ‚îÇ
‚îÇ    "status": "ACTIVE"                                    ‚îÇ
‚îÇ  }                                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìã Mapping Locations Summary

| Layer | What | Where | Example |
|-------|------|-------|---------|
| **Secondary Adapter (OUT)** | External ‚Üí Domain | API Client, DB Repository | `BalanceDto ‚Üí PulsaBalance` |
| **Service** | ‚ùå NO MAPPING | - | Only Domain objects |
| **Primary Adapter (IN)** | Domain ‚Üí Response | Controller | `PulsaBalance ‚Üí BalanceResponse` |

### **Key Points:**

1. **DTO is infrastructure concern** ‚Üí Lives in `infrastructure/`
2. **Mapping is technical concern** ‚Üí Done in Adapters
3. **Service never touches DTO** ‚Üí Only Domain
4. **Formatting/Parsing** ‚Üí Done in Adapters
5. **Business Rules** ‚Üí In Domain or Service

---

## üéØ Real-World Example: Bill Payment

### ‚ùå **WRONG** - Everything in Service

```java
@Service
public class BillPaymentService {
    
    protected List<BillItemDto> constructDenomUBP(
        List<BillItemDto> listDenomUBP, 
        String fee
    ) {
        List<BillItemDto> listDenom = new ArrayList<>();
        
        // ‚ùå Mixing: validation + mapping + formatting
        if (listDenomUBP != null && listDenomUBP.size() > 0) {
            for (BillItemDto data : listDenomUBP) {
                if (!StringUtils.isEmpty(data.getBillAmount())) {
                    BillItemDto obj = BillItemDto.builder()
                        .billCode(data.getBillCode())
                        .billAmount(data.getBillAmount())
                        // ‚ùå Formatting in service
                        .billName(AmountUtil.formatAmount(...))
                        // ‚ùå Business logic mixed with mapping
                        .billCustomerChargeAmount(
                            fee.equalsIgnoreCase("0") 
                                ? data.getBillCustomerChargeAmount() 
                                : fee
                        )
                        // ... more fields
                        .build();
                    
                    listDenom.add(obj);
                }
            }
        }
        return listDenom;
    }
    
    private List<BillItemDto> doInquiryDenom(BaseTransactionDataDto transaction) {
        // ‚ùå Too many responsibilities:
        // - External API calls
        // - Branching logic
        // - Mapping
        // - Sorting
        // - Caching
        
        List<BillItemDto> listDenom;
        
        if (transaction.getUbpHost().equalsIgnoreCase("SV")) {
            var denomRs = svBillPaymentService.inquiryDenomV2(transaction);
            listDenom = constructDenomSV(denomRs.getListDenom(), ...);
        } else {
            BillInquiryRs inquiryRs = billPaymentService.inquiry(transaction);
            listDenom = constructDenomUBP(inquiryRs.getBody().getBillItemList(), ...);
        }
        
        // Sorting
        Collections.sort(listDenom, ...);
        
        // Caching
        flowService.putCacheDenomList(...);
        
        return listDenom;
    }
}
```

**Problems:**
- Service tahu tentang DTO
- Mapping logic di service
- Technical details (caching, formatting) di service
- Hard to test
- Hard to maintain

---

### ‚úÖ **CORRECT** - Separated by Layer

#### **Domain:**
```java
// domain/entity/BillItem.java
public record BillItem(
    String code,
    BigDecimal amount,
    String formattedName,
    BigDecimal customerFee,
    BigDecimal companyFee
) {
    public boolean isValid() {
        return amount != null && amount.compareTo(BigDecimal.ZERO) > 0;
    }
    
    public BillItem withCustomerFee(BigDecimal fee) {
        return new BillItem(
            this.code,
            this.amount,
            this.formattedName,
            fee,  // ‚úÖ Business logic
            this.companyFee
        );
    }
    
    public int compareByAmount(BillItem other) {
        return this.amount.compareTo(other.amount);
    }
}
```

#### **Application:**
```java
// application/port/out/InquiryBillPort.java
public interface InquiryBillPort {
    Mono<List<BillItem>> inquiryByProvider(String provider, String customerId);
}

// application/service/BillInquiryService.java
@Service
public class BillInquiryService implements InquiryBillUseCase {
    
    private final InquiryBillPort inquiryBillPort;
    private final CacheBillPort cacheBillPort;
    
    @Override
    public Mono<List<BillItem>> inquiryDenom(InquiryCommand command) {
        return inquiryBillPort.inquiryByProvider(
                command.provider(), 
                command.customerId()
            )
            // ‚úÖ Business logic: filter & sort
            .map(items -> items.stream()
                .filter(BillItem::isValid)
                .sorted(BillItem::compareByAmount)
                .toList()
            )
            // ‚úÖ Orchestration: cache result
            .flatMap(items -> 
                cacheBillPort.cache(command.payeeCode(), items)
                    .thenReturn(items)
            );
    }
}
```

#### **Infrastructure:**
```java
// infrastructure/client/UbpBillClient.java
@Component
public class UbpBillClient implements InquiryBillPort {
    
    @Override
    public Mono<List<BillItem>> inquiryByProvider(String provider, String customerId) {
        if (!"UBP".equalsIgnoreCase(provider)) {
            return Mono.empty();
        }
        
        return webClient.post()
            .uri("/ubp/inquiry")
            .bodyValue(new UbpRequest(customerId))
            .retrieve()
            .bodyToMono(UbpResponse.class)
            .map(response -> response.getItems().stream()
                .map(this::toDomain)  // ‚úÖ MAPPING HERE
                .toList()
            );
    }
    
    /**
     * ‚úÖ MAPPING: BillItemDto ‚Üí BillItem
     */
    private BillItem toDomain(BillItemDto dto) {
        BigDecimal amount = new BigDecimal(dto.getBillAmount());
        
        return new BillItem(
            dto.getBillCode(),
            amount,
            formatAmount(amount),  // ‚úÖ Formatting in adapter
            new BigDecimal(dto.getBillCustomerChargeAmount()),
            new BigDecimal(dto.getBillCompanyChargeAmount())
        );
    }
    
    /**
     * ‚úÖ Technical utility
     */
    private String formatAmount(BigDecimal amount) {
        return String.format("%,d", amount.longValue());
    }
}

// infrastructure/client/SvBillClient.java
@Component
public class SvBillClient implements InquiryBillPort {
    // Similar structure but for SV provider
    // Each adapter has its own mapping logic
}

// infrastructure/composite/BillInquiryComposite.java
@Component
@Primary
public class BillInquiryComposite implements InquiryBillPort {
    // Routes to correct adapter based on provider
}
```

---

## üß™ Testing Benefits

### **Before (Without Hexagonal):**

```java
@Test
void testCheckBalance() {
    // ‚ùå Need to:
    // - Mock RestTemplate
    // - Mock RedisTemplate
    // - Setup test data in specific DTO format
    // - Mock JSON parsing
    // - Mock formatting utilities
    
    // Too many mocks, fragile test!
}
```

### **After (With Hexagonal):**

```java
@Test
void checkBalance_shouldReturnFromCache() {
    // ‚úÖ Mock ports only
    PulsaBalance cached = new PulsaBalance(
        "628123",
        new BigDecimal(50000),
        "XL",
        "ACTIVE"
    );
    
    when(cacheBalancePort.get("628123"))
        .thenReturn(Mono.just(cached));
    
    // Test
    Mono<PulsaBalance> result = service.checkBalance("628123");
    
    // Verify - SIMPLE!
    StepVerifier.create(result)
        .expectNext(cached)
        .verifyComplete();
    
    // ‚úÖ No Redis, no API, no DTO mocking needed!
    verify(loadBalancePort, never()).loadBalance(any());
}
```

---

## üéÅ Benefits

### **1. Easy to Replace Adapters**

```java
// Want to change from Redis to Hazelcast?
// Just create new adapter, service UNCHANGED!

@Component
public class HazelcastBalanceCache implements CacheBalancePort {
    // Different implementation, same contract
}
```

### **2. Multiple Implementations**

```java
// Can have multiple adapters for same port
@Component
class TelkomselClient implements LoadBalancePort { }

@Component
class XLClient implements LoadBalancePort { }

@Component
@Primary  // Default
class CompositeClient implements LoadBalancePort {
    // Routes to correct adapter
}
```

### **3. Clear Boundaries**

```
Domain      ‚Üê Pure business, no tech
Application ‚Üê Orchestration, uses ports
Infrastructure ‚Üê Technical details + MAPPING
```

### **4. Testability**

```java
// Mock ports, not implementations
when(port.method()).thenReturn(domain);
```

### **5. Maintainability**

- Change formatting? ‚Üí Change adapter only
- Change business rule? ‚Üí Change domain/service only
- Add new provider? ‚Üí Add new adapter only

---

## üìñ Summary

### **Where Mapping Happens:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  External System (API/DB)                               ‚îÇ
‚îÇ  Returns: DTO/Entity (external format)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
          ‚úÖ MAPPING HAPPENS HERE
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  SECONDARY ADAPTER                                      ‚îÇ
‚îÇ  - Calls external system                                ‚îÇ
‚îÇ  - Receives DTO/Entity                                  ‚îÇ
‚îÇ  ‚úÖ Maps: DTO ‚Üí Domain                                  ‚îÇ
‚îÇ  - Returns Domain to Service                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  SERVICE                                                ‚îÇ
‚îÇ  - Works ONLY with Domain objects                       ‚îÇ
‚îÇ  - Business logic                                       ‚îÇ
‚îÇ  - Orchestration                                        ‚îÇ
‚îÇ  ‚ùå NO DTO, NO MAPPING                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PRIMARY ADAPTER (Controller)                           ‚îÇ
‚îÇ  - Receives Domain from Service                         ‚îÇ
‚îÇ  ‚úÖ Maps: Domain ‚Üí Response DTO                         ‚îÇ
‚îÇ  - Returns JSON/HTTP response                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **3 Golden Rules:**

1. **Domain = Business Rules** (Pure, no dependencies)
2. **Service = Orchestration** (Uses ports, works with domain)
3. **Adapter = Technical + MAPPING** (DTO ‚Üî Domain conversion)

---

## üöÄ Next Steps

1. **Read:** `PURE_HEXAGONAL_ARCHITECTURE.md` for overall structure
2. **Read:** `COMPOSITE_ADAPTER_GUIDE.md` for multiple providers pattern
3. **Read:** `TDD_HEXAGONAL_WORKFLOW.md` for testing approach
4. **Practice:** Start refactoring helper methods to adapters
5. **Practice:** Extract business rules to domain entities

---

**üéØ Remember: MAPPING belongs to ADAPTER, NOT SERVICE!**

*If you find yourself doing DTO conversion in Service, it's a code smell.* üö®

